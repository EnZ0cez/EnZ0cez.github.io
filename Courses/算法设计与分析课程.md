# 算法设计与分析课程

## 第一章：算法复杂度分析

### 1.1算法基本概念

**算法是若干指令的有穷序列，满足性质**

* **输入**：有外部提供的量作为算法的输入。

* **输出**：算法产生至少一个量作为输出。

* **确定性**：组成算法的每条指令是清晰，无歧义的。

* **有限性**：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的。

* **可行性**: **算法是能够有效解决问题的**

### 1.2 分析插入排序

![image-20231128214316568](./_media/image-20231128214316568.png)

伪代码：

![image-20231128214521024](./_media/image-20231128214521024.png)

* 假定每次执行第i行所花的时间都是常量$c{_i}$
* j=2,,3,…,n,假定$t{_j}$表示对那个值j执行while循环测试的次数。
* 当一个for或while循环按通常的方式（由于循环头中的测试）退出时，执行测试的次数比执行循环体的次数多1。

$T(n)=c{_1}*n+c{_2}*(n-1)+c{_4}*(n-1)+c{_5}*\sum_{j=2}^n t{_j}$

$+c{_6}*\sum_{j=2}^n(t{_j}-1) +c{_7*\sum_{j=2}^n *(t{_j}-1)+c_8*(n-1)}$

最好情况：数组已经排好序

所有$t_j$均为1，$T(n)$可表示为$an+b$,其中常量a和b依赖于语句代价$c_i$

最坏情况：数组已逆序排好

$t_j=j$ , $T(n)=an^2+bn+c$

平均情况：

$E(t_j)=\frac{1}{j}(1+2+...+j)=\frac{j+1}{2} \approx \frac{j}{2}$

平均情况下的运行时间仍是n的二次函数

### 1.3渐近几号–O记号

<span style= color:blue>渐进上界</span>记号<span style="color:red">O</span>(大O)

渐近地给出了一个函数在常量因子内的上界:

$O(g(n)) = \{ f(n) : \exists c > 0, \exists n_0 > 0, \forall n \geq n_0, 0 \leq f(n) \leq c \cdot g(n) \}$

![image-20231128220710136](./_media/image-20231128220710136.png)

**渐近下界记号$\Omega$(大$\Omega$)**

渐近地给出了一个函数在常量因子内的下界:

$\Omega(g(n)) = \{ f(n) : \exists c > 0, \exists n_0 > 0, \forall n \geq n_0, 0 \leq c \cdot g(n) \leq f(n) \}$

![image-20231128221007056](./_media/image-20231128221007056.png)

**渐近紧确界记号$\Theta$**

渐近地给出了一个函数的上界和下界:

$\Theta(g(n)) = \{ f(n) : \exists c_1 > 0, \exists c_2 > 0, \exists n_0 > 0, \forall n \geq n_0, 0 \leq c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \}$

![image-20231128221446226](./_media/image-20231128221446226.png)

## 第二章：分治策略

将一个问题分解为与原问题相似但规模更小的若干子问题，递归地解这些子问题，然后将这些子问题的解结合起来构成原问题的解。这种方法在每层递归上均包括三个步骤

* Divide（分解）：将问题划分为若干个子问题
* Conquer（求解）：递归地解这些子问题；若子问题Size足够小，则直接解决之
* Combine（组合）：将子问题的解结合成原问题的解

### 递归算法

* 一个递归算法通常包含递归的调用该算法本身，传入较小的参数。

* 递归算法的中止条件：

	处理基本情况，这些情况不可以有任何递归调用。

![image-20231128222148237](./_media/image-20231128222148237.png)

### 分治算法的效率分析

* 用递归式分析分治算法的运行时间。
* 一个递归式是一个函数，它由一个或多个基本情况（base case），它自身，以及小参数组成。
* 递归式的解可以用来近似算法的运行时间。

#### 递归式求解方法1-迭代法

![image-20231129164420352](./_media/image-20231129164420352.png)

对于上图的递归式：

当n>1时T(n) = T(n-1)+1 =T(n-2)+1+1 =…  =T(1)+1+…+1         =T(1)+n-1= n

$\therefore T(n)\in \Theta(n)$

归并排序：

* 输入数组 A[p .. r] 

	![image-20231129165657793](./_media/image-20231129165657793.png)

* 递归式:

	![image-20231129165649708](./_media/image-20231129165649708.png)

![image-20231129165907719](./_media/image-20231129165907719.png)

$\therefore T(n) \in \Theta(n\log(n))$

#### 递归式求解方法2-主定理法

该方法可解如下形式的递归式

$T(n)=aT(n/b)+f(n)$

其描述的是这样一种算法的运行时间：它将规模为n的问题分解为啊个子问题，每个子问题规模为n/b，其中a和b都是正数。

其中 $$a\geq 1$$ 和 b > 1 是两个常数, f(n) 是一个渐进非负函数（当n趋于无穷时， f(n) 是非负的）。

如果 n/b 不是整数, 取整 n/b 

主方法可解包含三种类型 f(n) ($O、\Omega、\Theta$)的递归式  T(n) 。 

![image-20231129190825898](./_media/image-20231129190825898.png)

##### 使用主方法：

使用主方法很简单，我们只需确定主定理的哪种情况成立，即可得到解

**关键是看$f(n)$和$n^{\log_a^b}$谁比较大**

“较大” 指<span style="color:red">多项式意义上的大</span>, 大一个因子$n^{\varepsilon}$, for some $\varepsilon$> 0.

1. 若$n^{\log_a^b} > f(n)$ ，$T(n)=\Theta (n^{\log_a^b})$，属于情况(1)
2. 若$n^{\log_a^b} < f(n)$，$T(n)=\Theta(f(n))$，属于情况(3)
3. 若$n^{\log_a^b} = f(n)$，$T(n)=\Theta(n^{log_a^b})$，属于情况(2)

### 分治算法的设计

用分治算法来解决问题，通常思路为:

1. **划分（Divide）：** 将原问题划分成若干个规模较小且相互独立的子问题。这一步是问题分解的过程。
2. **征服（Conquer）：** 递归地解决这些子问题。对于规模足够小的子问题，直接求解。
3. **合并（Combine）：** 将子问题的解合并成原问题的解。这一步是问题合并的过程。

最经典的分治算法之一是归并排序（Merge Sort），它就是通过分治思想来进行排序的。其他例如快速排序、最近点对问题等问题也可以通过分治算法解决。

#### 1、二维最近点对问题

P1(x1,y1),...,Pn=(xn,yn)是平面上n个点构成的集合S，假设n=$2^k$，最近点对问题要求找出距离最近的两个点

![image-20231206201302005](./_media/image-20231206201302005.png)

1. 将点集S分为S1和S2，分隔线是S在x轴的中点（如何确定x=c?）
2. 递归求解S1和S2的最近点对，令d=min{d1,d2}，确定C1和C2
3. 将C1和C2的最近点对合并

最终会分为左右两边都只有一个点，并将这两个点的距离返回

property:合并时只考虑处在中轴线左右距离为d的范围内的点，在考虑每一个点时也只考虑点上下两端长度为d的范围之内的点

![image-20231206202112416](./_media/image-20231206202112416.png)

算法分析：

合并最小问题所花的时间为M(n)=O(n)

该算法的最差递归时间为：T(n)=2T(n/2)+n=O(nlogn)

#### 2、最大子数组问题

问题:

* 输入: 数值数组 A[1 .. n]
	* 假设数组中存在负数
	* 如果数组中全是非负数，该问题很简单。
* 输出: 数组下标 i 和 j 使得子数组 A[i .. j]为A[1 .. n]的和最大的非空连续子数组。

![image-20231206202514291](./_media/image-20231206202514291.png)

**分治算法：**

* 子问题 : 找出 A[low .. high] 的最大子数组。
	* 参数初始值, low = 1, high = n. 
	* **分解** 将子数组分解成两个大小基本相同的子数组找到子数组的中间位置 mid ，将子数组分成两个更小的子数组 A[low  .. mid] 和 A[mid +1 .. high]。
	* **求解** 找数组 A[low .. mid] 和 A[mid +1 .. high]的最大子数组。
	* 组合 找出跨越中间位置的最大子数组, 三种情况取和最大的子数组 (跨越中间位置的**最大**子数组和求解 步骤中找到的两个最大子数组)。

**找跨越中间位置的最大子数组**：

* 这是一个关键的新问题。

* 它不是原问题的一个小规模实例

	* 附加限制：子数组必须跨越中间位置。

* 这个问题可以用O(n) 时间解决。

	* 任何一个跨越中间位置 A[mid] 的子数组 A[i .. j] 由两个更小的子数组 A[i .. mid] 和 A[mid+1 .. j] 组成, 其中$low \leq \ i \leq mid < j \leq high $因此，只需要找两种形式的最大子数组 A[i .. mid] 和 A[mid+1 .. j], 然后把它们合并。

	从中间位置分别向左和右寻找最大子数组，往左依次累加值，往右依次累加值，并记录最大值的值和所在的位置，最后将左右的从中间开始的最大子数组合并。

	def find_max_crossing_subarray(arr, low, mid, high):
	    left_sum = float('-inf')
	    max_left = 0

	    # 从中间位置向左找到最大子数组
	    for i in range(mid, low - 1, -1):
	        max_left += arr[i]
	        if max_left > left_sum:
	            left_sum = max_left
	            max_left_index = i
	    
	    right_sum = float('-inf')
	    max_right = 0
	    
	    # 从中间位置向右找到最大子数组
	    for j in range(mid + 1, high + 1):
	        max_right += arr[j]
	        if max_right > right_sum:
	            right_sum = max_right
	            max_right_index = j
	    
	    # 计算横跨中间位置的最大子数组的和和索引
	    cross_sum = left_sum + right_sum
	    cross_start_index = max_left_index
	    cross_end_index = max_right_index
	    
	    return cross_sum, cross_start_index, cross_end_index

完整分治算法：

![image-20231206202926242](./_media/image-20231206202926242.png)

算法分析：

递归情况的递归式    T(n) = $\Theta$(1) + 2T(n/2) + $\Theta$(n) + $\Theta$(1) = 2T(n/2) + $\Theta$(n)

最大子数组分治算法运行时间为 $\Theta$(n lg n)，比蛮力法 $\Omega$(n2) 快。

#### 3、Strassen矩阵乘法

Strassen算法是一种分治算法，用于矩阵乘法。1969年，Volker Strassen发现了这种算法，它比传统的矩阵乘法算法（时间复杂度为O(n^3)）更快。传统的算法将两个n×n的矩阵相乘需要n^3次单独的乘法操作，而Strassen算法减少了乘法的次数，降低了时间复杂度到大约O(n^2.8074)。

Strassen算法的核心思想是将矩阵分割成四个子矩阵，然后对这些子矩阵进行递归操作。算法只需要7次乘法（而不是8次），因为它使用了一些额外的加法和减法来组合这些乘法的结果。

让我们用一个2x2的矩阵乘法例子来说明这个算法：

假设我们有两个矩阵A和B：

```
A = | a  b |    B = | e  f |
    | c  d |        | g  h |
```

普通的矩阵乘法会直接计算A和B的乘积：

```
AB = | ae+bg  af+bh |
     | ce+dg  cf+dh |
```

Strassen算法引入了七个新的乘法操作（P1到P7）来减少乘法的总次数：

```
P1 = a(f - h)       // a乘以(f-h)
P2 = (a + b)h       // (a+b)乘以h
P3 = (c + d)e       // (c+d)乘以e
P4 = d(g - e)       // d乘以(g-e)
P5 = (a + d)(e + h) // (a+d)乘以(e+h)
P6 = (b - d)(g + h) // (b-d)乘以(g+h)
P7 = (a - c)(e + f) // (a-c)乘以(e+f)
```

然后，我们可以用这七个乘法结果来构造最终的乘积矩阵C：

```
C = | P5 + P4 - P2 + P6    P1 + P2           |
    | P3 + P4              P1 + P5 - P3 - P7 |
```

实际上，我们用7次乘法和18次加法或减法取代了8次乘法和4次加法。

请注意，当矩阵大小增加时，Strassen算法的优势会更加明显。对于大型矩阵，我们会继续分割每个子矩阵，直到它们足够小，可以用常规方法或递归使用Strassen算法计算。

下面是一个简单的2x2矩阵乘法的例子，来演示Strassen算法的步骤：

假设我们有以下矩阵A和B：

```
A = | 1  2 |    B = | 3  4 |
    | 3  4 |        | 5  6 |
```

我们可以计算P1到P7：

```
P1 = 1 * (4 - 6) = -2
P2 = (1 + 2) * 6 = 18
P3 = (3 + 4) * 3 = 21
P4 = 4 * (5 - 3) = 8
P5 = (1 + 4) * (3 + 6) = 45
P6 = (2 - 4) * (5 + 6) = -12
P7 = (1 - 3) * (3 + 4) = -7
```

现在用这些值计算C的每个元素：

```
= | 45 + 8 - 18 - 12  -2 + 18     |
  | 21 + 8              -2 + 45 - 21 + 7 |
= | 23                   16        |
  | 29                   29        |
```

因此，矩阵C，即A乘以B的结果是：

```
| 23  16 |
| 29  29 |
```

Strassen算法是理解矩阵乘法和算法优化的一个很好的工具，尤其是在处理大规模数据时。然而，由于它涉及更多的加法和减法，所以它在实践中的效率可能会受到具体实现和计算环境的影响。

#### 4、凸包问题



#### 5、棋盘覆盖问题

