# 八股

## Java

### Hashmap的底层是用数组加链表实现的。

如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了。

所以在 JDK 1.8 版本的时候做了优化，当一个链表的长度超过8的时候就转换数据结构，不再使用链表存储，而是使用红黑树，查找时使用红黑树，时间复杂度O（log n），可以提高查询性能，但是在数量较少时，即数量小于6时，会将红黑树转换回链表。

### 哈希冲突如何解决？

Hashmap对于哈希冲突是用拉链法解决的，有新的键值对要插入到HashMap中时，会先计算键的哈希值，然后根据哈希值确定在数组中的位置。如果该位置已经有元素了，就会将新的元素插入到该位置的链表尾部（在 Java 8 及之后的版本中，当链表长度达到一定阈值时会转换为红黑树）。这样，同一个位置上的多个元素就通过链表（或红黑树）的方式连接起来，从而解决了哈希冲突。